/*
    Copyright 2008-2011
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with JSXGraph.  If not, see <http://www.gnu.org/licenses/>.
*/

##HEADER##

/*
    Default template driver for JS/CC generated parsers running as
    browser-based JavaScript/ECMAScript applications.
    
    WARNING:     This parser template will only run together with JSXGraph on a website.
    
    Features:
    - Parser trace messages
    - Integrated panic-mode error recovery
    
    Written 2007, 2008 by Jan Max Meyer, J.M.K S.F. Software Technologies
    Modified 2011 by Michael Gerhaeuser, JSXGraph
    
    This is in the public domain.
*/


JXG.extend(JXG.JessieCode.prototype, /** @lends JXG.JessieCode.prototype */ {
    /**
     * JS/CC interna
     * @type Boolean
     * @private
     */
    _dbg_withtrace: false,

    _dbg_withparsetree: false,

    _dbg_withstepbystep: false,

    /**
     * JS/CC interna
     * @type String
     * @private
     */
    _dbg_string: '',

    /**
     * JS/CC interna
     * @param {String} text
     * @private
     */
    _dbg_print: function (text) {
        this._dbg_string += text + "\n";
    },

    _dbg_flush: function () {
        alert(this._dbg_string);
    },

    _dbg_wait: function () {
        // Not implemented for Web.
    },

    _dbg_parsetree: function (indent, nodes, tree) {
        //Not implemented for Web.
    },

    /**
     * Internal lexer method.
     * @private
     */
    _lex: function (PCB) {
        var state,
            match = -1,
            match_pos = 0,
            start = 0,
            pos,
            chr;

        while (1) {
            state = 0;
            match = -1;
            match_pos = 0;
            start = 0;
            pos = PCB.offset + 1 + ( match_pos - start );

            do {

                pos--;
                state = 0;
                match = -2;
                start = pos;

                if( PCB.src.length <= start )
                    return ##EOF##;

                do {
                    chr = PCB.src.charCodeAt( pos );

##DFA##


                    //Line- and column-counter
                    if( state > -1 ) {
                        if( chr == 10 ) {
                            PCB.line++;
                            PCB.column = 0;
                        }
                        PCB.column++;
                    }

                    pos++;

                } while( state > -1 );

            } while (##WHITESPACE## > -1 && match == ##WHITESPACE##);

            if (match > -1) {
                PCB.att = PCB.src.substr( start, match_pos - start );
                PCB.offset = match_pos;
        
##TERMINAL_ACTIONS##
            } else {
                PCB.att = new String();
                match = -1;
            }

            break;
        }
        return match;
    },

    /**
     * Internal parse tree generator.
     * @param {String} src source code
     * @param {Array} err_off The positions where the errors occured are stored here.
     * @param {Array} err_la What the parser expected will be stored here.
     * @private
     */
    _parse: function (src, err_off, err_la) {
        var sstack = [],
            vstack = [],
            err_cnt = 0,
            act,
            i,

            //PCB: Parser Control Block
            parsercontrol = new Function( "",
                                "var la;" +
                                "var act;" +
                                "var offset;" +
                                "var src;" +
                                "var att;" +
                                "var line;" +
                                "var column;" +
                                "var error_step;" ),
            PCB = new parsercontrol(),

            //Visual parse tree generation
            treenode = new Function( "",
                                "var sym;"+
                                "var att;"+
                                "var child;" ),
            treenodes = new Array(),
            tree = new Array(),
            tmptree = null;


##TABLES##

##LABELS##

        PCB.line = 1;
        PCB.column = 1;
        PCB.offset = 0;
        PCB.error_step = 0;
        PCB.src = src;
        PCB.att = new String();
    
        if( !err_off ) {
            err_off = new Array();
        }
        if( !err_la ) {
            err_la = new Array();
        }

        sstack.push( 0 );
        vstack.push( 0 );
    
        PCB.la = this._lex(PCB);
            
        while( true ) {
            PCB.act = ##ERROR##;
            for( var i = 0; i < act_tab[sstack[sstack.length-1]].length; i+=2 ) {
                if( act_tab[sstack[sstack.length-1]][i] == PCB.la ) {
                    PCB.act = act_tab[sstack[sstack.length-1]][i+1];
                    break;
                }
            }
        
            if( PCB.act == ##ERROR## ) {
                if( ( PCB.act = defact_tab[ sstack[sstack.length-1] ] ) < 0 )
                    PCB.act = ##ERROR##;
                else
                    PCB.act *= -1;
            }

        if( this._dbg_withtrace && sstack.length > 0 )
        {
            this._dbg_print( "\nState " + sstack[sstack.length-1] + "\n" +
                            "\tLookahead: " + labels[PCB.la] +
                                " (\"" + PCB.att + "\")\n" +
                            "\tAction: " + PCB.act + "\n" + 
                            "\tSource: \"" + PCB.src.substr( PCB.offset, 30 ) +
                                    ( ( PCB.offset + 30 < PCB.src.length ) ?
                                        "..." : "" ) + "\"\n" +
                            "\tStack: " + sstack.join() + "\n" +
                            "\tValue stack: " + vstack.join() + "\n" );
            
            if( this._dbg_withstepbystep )
                this._dbg_wait();
        }
        
            
        //Parse error? Try to recover!
        if( PCB.act == ##ERROR## )
        {
            if( this._dbg_withtrace )
            {
                var expect = new String();
                
                this._dbg_print( "Error detected: " +
                    "There is no reduce or shift on the symbol " +
                        labels[PCB.la] );
                
                for( var i = 0; i < act_tab[sstack[sstack.length-1]].length;
                        i+=2 )
                {
                    if( expect != "" )
                        expect += ", ";
                        
                    expect += "\"" +
                                labels[ act_tab[sstack[sstack.length-1]][i] ]
                                    + "\"";
                }
                
                this._dbg_print( "Expecting: " + expect );
            }
            
            //Report errors only when error_step is 0, and this is not a
            //subsequent error from a previous parse
            if( PCB.error_step == 0 )
            {
                err_cnt++;
                err_off.push( {offset: PCB.offset - PCB.att.length, line: PCB.line} );
                err_la.push( new Array() );
                for( var i = 0; i < act_tab[sstack[sstack.length-1]].length;
                        i+=2 )
                    err_la[err_la.length-1].push(
                            labels[act_tab[sstack[sstack.length-1]][i]] );
            }
            
            //Perform error recovery            
            while( sstack.length > 1 && PCB.act == ##ERROR## )
            {
                sstack.pop();
                vstack.pop();
                
                //Try to shift on error token
                for( var i = 0; i < act_tab[sstack[sstack.length-1]].length;
                        i+=2 )
                {
                    if( act_tab[sstack[sstack.length-1]][i] == ##ERROR_TOKEN## )
                    {
                        PCB.act = act_tab[sstack[sstack.length-1]][i+1];
                        
                        sstack.push( PCB.act );
                        vstack.push( new String() );
                        
                        if( this._dbg_withtrace )
                        {
                            this._dbg_print(
                                "Error recovery: error token " +
                                    "could be shifted!" );
                            this._dbg_print( "Error recovery: " +
                                    "current stack is " + sstack.join() );
                        }

                        break;
                    }
                }
            }
            
            //Is it better to leave the parser now?
            if( sstack.length > 1 && PCB.act != ##ERROR## )
            {
                //Ok, now try to shift on the next tokens
                while( PCB.la != ##EOF## )
                {
                    if( this._dbg_withtrace )
                        this._dbg_print( "Error recovery: " +
                            "Trying to shift on \""
                                + labels[ PCB.la ] + "\"" );

                    PCB.act = ##ERROR##;
                    
                    for( var i = 0; i < act_tab[sstack[sstack.length-1]].length;
                            i+=2 )
                    {
                        if( act_tab[sstack[sstack.length-1]][i] == PCB.la )
                        {
                            PCB.act = act_tab[sstack[sstack.length-1]][i+1];
                            break;
                        }
                    }
                    
                    if( PCB.act != ##ERROR## )
                        break;
                        
                    if( this._dbg_withtrace )
                        this._dbg_print( "Error recovery: Discarding \""
                            + labels[ PCB.la ] + "\"" );
                    
                    while( ( PCB.la = this._lex( PCB ) )
                                < 0 )
                        PCB.offset++;
                
                    if( this._dbg_withtrace )
                        this._dbg_print( "Error recovery: New token \""
                            + labels[ PCB.la ] + "\"" );
                }
                while( PCB.la != ##EOF## && PCB.act == ##ERROR## );
            }
            
            if( PCB.act == ##ERROR## || PCB.la == ##EOF## )
            {
                if( this._dbg_withtrace )
                    this._dbg_print( "\tError recovery failed, " +
                            "terminating parse process..." );
                break;
            }

            if( this._dbg_withtrace )
                this._dbg_print( "\tError recovery succeeded, " +
                                            "continuing" );
            
            //Try to parse the next three tokens successfully...
            PCB.error_step = 3;
        }

        //Shift
        if( PCB.act > 0 )
        {
            //Parse tree generation
            if( this._dbg_withparsetree )
            {
                var node = new treenode();
                node.sym = labels[ PCB.la ];
                node.att = PCB.att;
                node.child = new Array();
                tree.push( treenodes.length );
                treenodes.push( node );
            }
            
            if( this._dbg_withtrace )
                this._dbg_print( "Shifting symbol: " +
                        labels[PCB.la] + " (" + PCB.att + ")" );
        
            sstack.push( PCB.act );
            vstack.push( PCB.att );
            
            PCB.la = this._lex( PCB );
            
            if( this._dbg_withtrace )
                this._dbg_print( "\tNew lookahead symbol: " +
                        labels[PCB.la] + " (" + PCB.att + ")" );
                
            //Successfull shift and right beyond error recovery?
            if( PCB.error_step > 0 )
                PCB.error_step--;
        }
        //Reduce
        else
        {        
            act = PCB.act * -1;
            
            if( this._dbg_withtrace )
                this._dbg_print( "Reducing by production: " + act );
            
            rval = void( 0 );
            
            if( this._dbg_withtrace )
                this._dbg_print( "\tPerforming semantic action..." );
            
##ACTIONS##
            
            if( this._dbg_withparsetree )
                tmptree = new Array();

            if( this._dbg_withtrace )
                this._dbg_print( "\tPopping " +
                                    pop_tab[act][1] +  " off the stack..." );
                
            for( var i = 0; i < pop_tab[act][1]; i++ )
            {
                if( this._dbg_withparsetree )
                    tmptree.push( tree.pop() );
                    
                sstack.pop();
                vstack.pop();
            }

            //Get goto-table entry
            PCB.act = ##ERROR##;
            for( var i = 0; i < goto_tab[sstack[sstack.length-1]].length; i+=2 )
            {
                if( goto_tab[sstack[sstack.length-1]][i] == pop_tab[act][0] )
                {
                    PCB.act = goto_tab[sstack[sstack.length-1]][i+1];
                    break;
                }
            }
            
            //Do some parse tree construction if desired
            if( this._dbg_withparsetree )
            {
                var node = new treenode();
                node.sym = labels[ pop_tab[act][0] ];
                node.att = rval;
                node.child = tmptree.reverse();
                tree.push( treenodes.length );
                treenodes.push( node );
            }
            
            //Goal symbol match?
            if( act == 0 ) //Don't use PCB.act here!
                break;
                
            if( this._dbg_withtrace )
                this._dbg_print( "\tPushing non-terminal " +
                        labels[ pop_tab[act][0] ] );
            
            //...and push it!
            sstack.push( PCB.act );
            vstack.push( rval );
        }
    }

    if( this._dbg_withtrace )
    {
        this._dbg_print( "\nParse complete." );
        
        //This function is used for parser drivers that will output
        //the entire debug messages in a row.
        this._dbg_flush();
    }

    if( this._dbg_withparsetree )
    {
        if( err_cnt == 0 )
        {
            this._dbg_print( "\n\n--- Parse tree ---" );
            this._dbg_parsetree( 0, treenodes, tree );
        }
        else
        {
            this._dbg_print( "\n\nParse tree cannot be viewed. " +
                                    "There where parse errors." );
        }
    }
    
    return err_cnt;
}

});

##FOOTER##

