// $BUILDMARKER$START
/*
    Copyright 2008-2011
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with JSXGraph.  If not, see <http://www.gnu.org/licenses/>.
*/

##HEADER##

/*
    Default template driver for JS/CC generated parsers running as
    browser-based JavaScript/ECMAScript applications.
    
    WARNING:     This parser template will only run together with JSXGraph on a website.
    
    Features:
    - Parser trace messages
    - Integrated panic-mode error recovery
    
    Written 2007, 2008 by Jan Max Meyer, J.M.K S.F. Software Technologies
    Modified 2011 by Michael Gerhaeuser, JSXGraph
    
    This is in the public domain.
*/

// $BUILDMARKER$END

/*global JXG: true*/
/*jslint nomen: true, plusplus: true*/

(function () {

    "use strict";

    // $BUILDMARKER$START

    JXG.extend(JXG.JessieCode.prototype, /** @lends JXG.JessieCode.prototype */ {
        /**
         * Internal lexer method.
         * @private
         */
        lex: function (PCB) {
            var state, match, match_pos, start, pos, chr;

            state = 0;
            match = -1;
            match_pos = 0;
            start = 0;
            pos = PCB.offset + 1 + (match_pos - start);

            do {
                pos -= 1;
                state = 0;
                match = -2;
                start = pos;

                if (PCB.src.length <= start) {
                    return ##EOF##;
                }

                do {
                    chr = PCB.src.charCodeAt(pos);

    ##DFA##

                    //Line- and column-counter
                    if (state > -1) {
                        if (chr === 10) {
                            PCB.line += 1;
                            PCB.column = 0;
                            if (this.countLines) {
                                this.parCurLine = PCB.line;
                            }
                        }
                        PCB.column += 1;
                        if (this.countLines) {
                            this.parCurColumn = PCB.column;
                        }
                    }

                    pos += 1;

                } while (state > -1);

            } while (##WHITESPACE## > -1 && match === ##WHITESPACE##);

            if (match > -1) {
                PCB.att = PCB.src.substr(start, match_pos - start);
                PCB.offset = match_pos;

    ##TERMINAL_ACTIONS##
            } else {
                PCB.att = '';
                match = -1;
            }

            return match;
        },

        /**
         * Internal parse tree generator.
         * @param {String} src source code
         * @param {Array} err_off The positions where the errors occured are stored here.
         * @param {Array} err_la What the parser expected will be stored here.
         * @private
         */
        genTree: function (src, err_off, err_la) {
            var act, undef, rval, i, pop_tab, act_tab, goto_tab, defact_tab, labels,
                sstack = [],
                vstack = [],
                err_cnt = 0,
                PCB = {
                    la: 0,
                    act: 0,
                    offset: 0,
                    src: src,
                    att: '',
                    line: 1,
                    column: 1,
                    error_step: 0
                };

    ##TABLES##

    ##LABELS##

            if (!err_off) {
                err_off = [];
            }
            if (!err_la) {
                err_la = [];
            }

            sstack.push(0);
            vstack.push(0);

            PCB.la = this.lex(PCB);

            while (true) {
                PCB.act = ##ERROR##;
                for (i = 0; i < act_tab[sstack[sstack.length - 1]].length; i += 2) {
                    if (act_tab[sstack[sstack.length - 1]][i] === PCB.la) {
                        PCB.act = act_tab[sstack[sstack.length - 1]][i + 1];
                        break;
                    }
                }

                if (PCB.act === ##ERROR##) {
                    if ((PCB.act = defact_tab[sstack[sstack.length - 1]]) < 0) {
                        PCB.act = ##ERROR##;
                    } else {
                        PCB.act *= -1;
                    }
                }

                //Parse error? Try to recover!
                if (PCB.act === ##ERROR##) {
                    //Report errors only when error_step is 0, and this is not a
                    //subsequent error from a previous parse
                    if (PCB.error_step === 0) {
                        err_cnt += 1;
                        err_off.push({offset: PCB.offset - PCB.att.length, line: PCB.line});
                        err_la.push([]);
                        for (i = 0; i < act_tab[sstack[sstack.length - 1]].length; i += 2) {
                            err_la[err_la.length - 1].push(labels[act_tab[sstack[sstack.length - 1]][i]]);
                        }
                    }

                    //Perform error recovery
                    while (sstack.length > 1 && PCB.act === ##ERROR##) {
                        sstack.pop();
                        vstack.pop();

                        //Try to shift on error token
                        for (i = 0; i < act_tab[sstack[sstack.length - 1]].length; i += 2) {
                            if (act_tab[sstack[sstack.length - 1]][i] === ##ERROR_TOKEN##) {
                                PCB.act = act_tab[sstack[sstack.length - 1]][i + 1];

                                sstack.push(PCB.act);
                                vstack.push('');

                                break;
                            }
                        }
                    }

                    //Is it better to leave the parser now?
                    if (sstack.length > 1 && PCB.act !== ##ERROR##) {
                        //Ok, now try to shift on the next tokens
                        while (PCB.la !== ##EOF##) {
                            PCB.act = ##ERROR##;

                            for (i = 0; i < act_tab[sstack[sstack.length - 1]].length; i += 2) {
                                if (act_tab[sstack[sstack.length - 1]][i] === PCB.la) {
                                    PCB.act = act_tab[sstack[sstack.length - 1]][i + 1];
                                    break;
                                }
                            }

                            if (PCB.act !== ##ERROR##) {
                                break;
                            }

                            while ((PCB.la = this.lex(PCB)) < 0) {
                                PCB.offset += 1;
                            }
                        }

                        //while (PCB.la !== ##EOF## && PCB.act === ##ERROR##) {}
                    }

                    if (PCB.act === ##ERROR## || PCB.la === ##EOF##) {
                        break;
                    }

                    //Try to parse the next three tokens successfully...
                    PCB.error_step = 3;
                }

                //Shift
                if (PCB.act > 0) {
                    sstack.push(PCB.act);
                    vstack.push(PCB.att);

                    PCB.la = this.lex(PCB);

                    //Successfull shift and right beyond error recovery?
                    if (PCB.error_step > 0) {
                        PCB.error_step -= 1;
                    }
                //Reduce
                } else {
                    act = -PCB.act;
                    rval = undef;

    ##ACTIONS##

                    for (i = 0; i < pop_tab[act][1]; i++) {
                        sstack.pop();
                        vstack.pop();
                    }

                    //Get goto-table entry
                    PCB.act = ##ERROR##;
                    for (i = 0; i < goto_tab[sstack[sstack.length - 1]].length; i += 2) {
                        if (goto_tab[sstack[sstack.length - 1]][i] === pop_tab[act][0]) {
                            PCB.act = goto_tab[sstack[sstack.length - 1]][i + 1];
                            break;
                        }
                    }

                    //Goal symbol match?

                    //Don't use PCB.act here!
                    if (act === 0) {
                        break;
                    }

                    //...and push it!
                    sstack.push(PCB.act);
                    vstack.push(rval);
                }
            }

            return err_cnt;
        }

    });

##FOOTER##

    // $BUILDMARKER$END

}());