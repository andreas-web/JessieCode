/*
    Copyright 2008-2011
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with JSXGraph.  If not, see <http://www.gnu.org/licenses/>.
*/

##HEADER##

/*
    Default template driver for JS/CC generated parsers running as
    browser-based JavaScript/ECMAScript applications.
    
    WARNING:     This parser template will only run together with JSXGraph on a website.
    
    Features:
    - Parser trace messages
    - Integrated panic-mode error recovery
    
    Written 2007, 2008 by Jan Max Meyer, J.M.K S.F. Software Technologies
    Modified 2011 by Michael Gerhaeuser, JSXGraph
    
    This is in the public domain.
*/


JXG.extend(JXG.JessieCode.prototype, /** @lends JXG.JessieCode.prototype */ {
    /**
     * Internal lexer method.
     * @private
     */
    _lex: function (PCB) {
        var state,
            match = -1,
            match_pos = 0,
            start = 0,
            pos,
            chr;

        while (1) {
            state = 0;
            match = -1;
            match_pos = 0;
            start = 0;
            pos = PCB.offset + 1 + ( match_pos - start );

            do {

                pos--;
                state = 0;
                match = -2;
                start = pos;

                if( PCB.src.length <= start )
                    return ##EOF##;

                do {
                    chr = PCB.src.charCodeAt( pos );

##DFA##

                    //Line- and column-counter
                    if( state > -1 ) {
                        if( chr == 10 ) {
                            PCB.line++;
                            PCB.column = 0;
                            if (this.countLines) {
                                this.parCurLine = PCB.line;
                                this.parCurColumn = PCB.column;
                            }
                        }
                        PCB.column++;
                    }

                    pos++;

                } while( state > -1 );

            } while (##WHITESPACE## > -1 && match == ##WHITESPACE##);

            if (match > -1) {
                PCB.att = PCB.src.substr( start, match_pos - start );
                PCB.offset = match_pos;
        
##TERMINAL_ACTIONS##
            } else {
                PCB.att = new String();
                match = -1;
            }

            break;
        }
        return match;
    },

    /**
     * Internal parse tree generator.
     * @param {String} src source code
     * @param {Array} err_off The positions where the errors occured are stored here.
     * @param {Array} err_la What the parser expected will be stored here.
     * @private
     */
    _parse: function (src, err_off, err_la) {
        var sstack = [],
            vstack = [],
            err_cnt = 0,
            act,
            rval,
            i,

            PCB = {
                la: 0,
                act: 0,
                offset: 0,
                src: src,
                att: '',
                line: 1,
                column: 1,
                error_step: 0
            };

##TABLES##

##LABELS##

        if( !err_off ) {
            err_off = [];
        }
        if( !err_la ) {
            err_la = [];
        }

        sstack.push(0);
        vstack.push(0);
    
        PCB.la = this._lex(PCB);
            
        while( true ) {
            PCB.act = ##ERROR##;
            for( i = 0; i < act_tab[sstack[sstack.length-1]].length; i+=2 ) {
                if( act_tab[sstack[sstack.length-1]][i] == PCB.la ) {
                    PCB.act = act_tab[sstack[sstack.length-1]][i+1];
                    break;
                }
            }
        
            if( PCB.act == ##ERROR## ) {
                if( ( PCB.act = defact_tab[ sstack[sstack.length-1] ] ) < 0 )
                    PCB.act = ##ERROR##;
                else
                    PCB.act *= -1;
            }

            //Parse error? Try to recover!
            if( PCB.act == ##ERROR## )
            {
                //Report errors only when error_step is 0, and this is not a
                //subsequent error from a previous parse
                if( PCB.error_step == 0 )
                {
                    err_cnt++;
                    err_off.push( {offset: PCB.offset - PCB.att.length, line: PCB.line} );
                    err_la.push([]);
                    for( i = 0; i < act_tab[sstack[sstack.length-1]].length; i+=2 )
                        err_la[err_la.length-1].push(
                                labels[act_tab[sstack[sstack.length-1]][i]] );
                }
            
                //Perform error recovery
                while( sstack.length > 1 && PCB.act == ##ERROR## )
                {
                    sstack.pop();
                    vstack.pop();
                
                    //Try to shift on error token
                    for( i = 0; i < act_tab[sstack[sstack.length-1]].length; i+=2 )
                    {
                        if( act_tab[sstack[sstack.length-1]][i] == ##ERROR_TOKEN## )
                        {
                            PCB.act = act_tab[sstack[sstack.length-1]][i+1];
                        
                            sstack.push( PCB.act );
                            vstack.push( '' );
                        
                            break;
                        }
                    }
                }
            
                //Is it better to leave the parser now?
                if( sstack.length > 1 && PCB.act != ##ERROR## )
                {
                    //Ok, now try to shift on the next tokens
                    while( PCB.la != ##EOF## )
                    {
                        PCB.act = ##ERROR##;
                    
                        for( i = 0; i < act_tab[sstack[sstack.length-1]].length; i+=2 )
                        {
                            if( act_tab[sstack[sstack.length-1]][i] == PCB.la )
                            {
                                PCB.act = act_tab[sstack[sstack.length-1]][i+1];
                                break;
                            }
                        }
                    
                        if( PCB.act != ##ERROR## )
                            break;
                        
                        while( ( PCB.la = this._lex( PCB ) ) < 0 )
                            PCB.offset++;
                    }
                    while( PCB.la != ##EOF## && PCB.act == ##ERROR## ) {}
                }
            
                if( PCB.act == ##ERROR## || PCB.la == ##EOF## )
                {
                    break;
                }

                //Try to parse the next three tokens successfully...
                PCB.error_step = 3;
            }

            //Shift
            if( PCB.act > 0 )
            {
                sstack.push( PCB.act );
                vstack.push( PCB.att );
            
                PCB.la = this._lex( PCB );
            
                //Successfull shift and right beyond error recovery?
                if( PCB.error_step > 0 )
                    PCB.error_step--;
            }
            //Reduce
            else
            {
                act = PCB.act * -1;
            
                rval = void( 0 );
            
##ACTIONS##
            
                for( i = 0; i < pop_tab[act][1]; i++ )
                {
                    sstack.pop();
                    vstack.pop();
                }

                //Get goto-table entry
                PCB.act = ##ERROR##;
                for( i = 0; i < goto_tab[sstack[sstack.length-1]].length; i+=2 )
                {
                    if( goto_tab[sstack[sstack.length-1]][i] == pop_tab[act][0] )
                    {
                        PCB.act = goto_tab[sstack[sstack.length-1]][i+1];
                        break;
                    }
                }
            
                //Goal symbol match?
                if( act == 0 ) //Don't use PCB.act here!
                    break;
                
                //...and push it!
                sstack.push( PCB.act );
                vstack.push( rval );
            }
        }

        return err_cnt;
    }

});

##FOOTER##

